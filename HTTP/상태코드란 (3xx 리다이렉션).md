# HTTP 상태코드 (3xx 리다이렉션)

우리가 사용하는 모든 웹 기술은 HTTP 기반 위에서 작동된다.<br/>
웹을 다루는 개발자라면, 내가 개발한 애플리케이션의 통신 상태를 파악하는 것은 필수적이다.<br/>
따라서 HTTP 상태코드에 대해서 알아보도록 하자.<br/>
<br/>

### 목차
- 상태코드의 종류
- 3xx 리다이렉션이란?
  - 영구적 리다이렉션
  - 일시적 리다이렉션(+PRG)
<br/>

## 상태코드의 종류
상태코드란 클라이언트가 보낸 요청의 처리상태를 응답해서 알려주는 기능이다.<br/>
HTTP의 상태코드는 100~500번대로 정의되어 있으며, 우리는 1 ~ 5의 숫자로 클라이언트의 요청 상태를 짐작해볼 수 있다.<br/>
- 1xx (Informational) : 클라이언트의 요청이 수신되어 처리중
- 2xx (Successful) : 클라이언트의 요청이 정상적으로 처리가 완료 되었음
- 3xx (Redirection) : 클라이언트의 요청을 완료하려면 추가적인 행동이 필요함
- 4xx (Client Error) : 클라이언트 오류, 잘못된 문법등으로 서버가 요청을 수행할 수 없음
- 5xx (Server Error) : 서버 오류, 서버가 정상 요청을 처리하지 못함

<br/>

## 3xx 리다이렉션이란?
1 ~ 5번대의 상태코드를 보면 대략적인 상태를 알 수 있다고 하였다. <br/>
이 중에서 조금 생소하고 들었을 때 확 와닿지 않은 3xx 리다이렉션의 대해서 정리해 보려고 한다. <br/>
<br/>
리다이렉션이란, 클라이언트의 요청이 들어왔을 때, 서버는 새로운 url을 응답해 클라이언트에게 추가적인 행동을 하도록 유도하는 것이다.

리다이렉션에는 2가지가 있다.
- 영구적 리다이렉션
- 일시적 리다이렉션

<br/>

### 영구적 리다이렉션
먼저 영구적 리다이렉션은 클라이언트가 어떤 url을 요청했을 때 서버에서는 해당 url를 받았을 때, <br/>
새로운 url로 요청할 수 있도록 응답헤더에 3xx번대 상태코드와 함께 url정보를 함께 넘겨준다. 이때의 url은 영구적으로 이동한 것을 의미한다. <br/>
이 때, 상태코드의 따라 GET 혹은 POST방식으로 클라이언트가 재요청을 할 수 있도록 정해줄 수 있는데, <br/>
일반적으로 url이 변경되면 클라이언트가 요청메시지 부분을 다시 작성하는게 좋다고 한다. 그림을 살펴보자.

- 영구 리다이렉션 - 301
<img width="800" src="https://user-images.githubusercontent.com/76789355/166908687-ae9cdd29-279a-47c6-8436-93821ffacb3a.png">
👉 301번 상태코드는 클라이언트의 요청을 GET방식의 요청으로 변경해주는 영구 리다이렉션 상태코드이다. <br/>
클라이언트가 /event라는 url을 요청했을 때 서버에서는 /event라는 url이 들어오면, <br/> 
/new-event로 접근할 수 있도록 상태코드 301과 함께 새로운 url을 넘겨준다. <br/>
서버는 상태코드 301번으로 클라이언트에게 응답했기 때문에 클라이언트는 POST요청을 하였던 이전 요청과 달리 GET요청으로 재요청하게 된다. <br/>
여기서 POST요청을 했을 때와 달리 GET요청으로 변경되었기 때문에 요청헤더로 url만 보낼뿐 요청바디부분이 없는 것을 알 수 있다. <br/><br/>

- 영구 리다이렉션 - 308
<img width="800" src="https://user-images.githubusercontent.com/76789355/166908740-0054f694-6e0e-4258-bfda-02bb57783f0b.png">
👉 308번 상태코드는 클라이언트의 요청을 POST요청으로 변경해주는 영구 리다이렉션 상태코드이다. <br/>
클라이언트가 /event라는 url을 요청했을 때 서버에서는 /event라는 url이 들어오면, <br/> 
/new-event로 접근할 수 있도록 상태코드 308과 함께 새로운 url을 넘겨준다. <br/>
서버는 상태코드 308번으로 클라이언트에게 응답했기 때문에 클라이언트는 POST로 이전에 요청했던 요청바디부분과 재요청하게 된다. <br/>

### 일시적 리다이렉션
일시적 리다이렉션은 url이 일시적으로 변경되는 것을 말한다. <br/>
영구 리다이렉션 처럼 일시적 리다이렉션의 상태코드도 존재한다 -> 302(GET or POST) , 307(POST), 303(GET) <br/>
일시적 리다이렉션은 <b>PRG</b>라는 개념이 있다. <b>(Post - Redirection - Get)</b> <br/>
주문등록 시 새로고침을 했을 때를 예시로 PRG를 적용하기 전과 후를 비교해보자. <br/>
💡여기서 새로고침(F5)은 클라이언트가 요청했던 내용을 다시 요청하는 것을 말한다. 이점을 생각하고 아래 그림을 보도록 하자.💡 <br/>

- PRG 적용 전
<img width="800" src="https://user-images.githubusercontent.com/76789355/166912381-7c1d31f9-47ce-4162-a93a-cf57326e8aad.png">
👉 PRG를 적용하기 전에는 클라이언트가 주문을 요청하면 서버는 주문정보를 DB에 저장하고 응답으로 200 OK를 보낸다. <br/>
이 때, 클라이언트가 결과하면에서 새로고침을 하게되면 이전에 요청했던(POST /order)정보를 다시 서버에 보내게 된다. <br/>
즉, 중복으로 주문요청을 하게되고, 동일한 주문데이터가 2개 생성될 수 있다. <br/>
이러한 상황을 방지하기 위해 PRG를 적용해보자. <br/><br/>

- PRG 적용 후
<img width="800" src="https://user-images.githubusercontent.com/76789355/166912432-1e5a0ebf-e9d4-46a1-961c-5b1d49fe81d2.png">
👉 PRG를 적용하면, 클라이언트가 주문을 요청하면 서버는 주문정보를 DB에 저장하고, <br/>
응답으로 상태코드 302 Found와 함께 주문완료 url(/order-result/19)를 보낸다. <br/>
그러면 클라이언트는 주문이 완료되면 /order -> /order-result/19로 일시적 리다이렉션을 하게 되고, <br/>
새로고침을 해도 다시 주문등록을 하지 않고, 주문완료한 상세내역을 조회하는 GET요청을 하게된다. <br/>
따라서, 중복 주문을 막을 수 있다. <br/>

<br/>

위에서 주문등록을 예로 들었지만, 다양한 상황에서 중복으로 등록되는 것을 막아야 할 상황이 많을 것이다. <br/>
물론, POST등록이 왔을 때 서버에서 중복체크를 함으로 중복을 막을 수도 있다. <br/>
하지만 HTTP 상태코드를 공부한 개발자라면 서버에서 체크 + 상태코드를 제어함으로 중복 등록을 선제적으로 차단하는 선택지를 하나 더 생각해볼 수 있게 된 것이다. <br/>

- - -

이 글은 김영한의 '모든 개발자를 위한 HTTP 웹 기본 지식'강의를 기반으로 작성하였습니다.
